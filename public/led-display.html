<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Display Zones - OBS</title>
    <style>
        @font-face {
            font-family: 'HelveticaNeue';
            src: url('https://gmrxbbhhyyrtmsftofdp.supabase.co/storage/v1/object/public/gentle-mates-assets/livedata-overlay/HelveticaNeueBold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
        }
        @font-face {
            font-family: 'HelveticaNeue-Bold';
            src: url('https://gmrxbbhhyyrtmsftofdp.supabase.co/storage/v1/object/public/gentle-mates-assets/livedata-overlay/HelveticaNeueBold.ttf') format('truetype');
            font-weight: bold;
            font-style: normal;
        }
        @font-face {
            font-family: 'HelveticaBoldExtended';
            src: url('https://gmrxbbhhyyrtmsftofdp.supabase.co/storage/v1/object/public/gentle-mates-assets/livedata-overlay/HelveticaNeue-BlackExt.otf') format('opentype');
            font-weight: bold;
            font-style: normal;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            font-family: 'HelveticaNeue', Arial, sans-serif;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1056" height="384"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let animationId;
        let scrollOffset1 = 0, scrollOffset2 = 0, scrollOffset3 = 0, scrollOffset4 = 0;
        let isAnimating = true;
        
        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        
        const zones = [
            { 
                x: 0, y: 0, width: 1056, height: 96, 
                color: '#000000', 
                text: urlParams.get('zone1text') || 'ZONE 1 üëæ',
                textColor: urlParams.get('zone1color') || '#ff00ec',
                speed: parseFloat(urlParams.get('zone1speed')) || 2
            },
            { 
                x: 0, y: 96, width: 1056, height: 96, 
                color: '#000000', 
                text: urlParams.get('zone2text') || 'ZONE 2 üëÄ',
                textColor: urlParams.get('zone2color') || '#ff00ec',
                speed: parseFloat(urlParams.get('zone2speed')) || 1.5
            },
            { 
                x: 0, y: 192, width: 1056, height: 96, 
                color: '#000000', 
                text: urlParams.get('zone3text') || 'ZONE 3 üöÄ',
                textColor: urlParams.get('zone3color') || '#ff00ec',
                speed: parseFloat(urlParams.get('zone3speed')) || 2.5
            },
            { 
                x: 0, y: 288, width: 864, height: 96, 
                color: '#000000', 
                text: urlParams.get('zone4text') || 'ZONE 4 üåç',
                textColor: urlParams.get('zone4color') || '#ff00ec',
                speed: parseFloat(urlParams.get('zone4speed')) || 1.8
            }
        ];
        
        const scrollOffsets = [0, 0, 0, 0];
        
        function drawZone(zone, zoneIndex) {
            ctx.fillStyle = zone.color;
            ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 0;
            ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
            
            const fontSize = 48;
            ctx.font = `bold ${fontSize}px 'HelveticaBoldExtended', 'HelveticaNeue-Bold', 'HelveticaNeue', Arial, sans-serif`;
            ctx.fillStyle = zone.textColor;
            ctx.shadowColor = zone.textColor;
            ctx.shadowBlur = 0;
            
            const textWidth = ctx.measureText(zone.text).width;
            const spacing = 50;
            const totalWidth = textWidth + spacing;
            
            const y = zone.y + (zone.height / 2) + (fontSize / 3);
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(zone.x, zone.y, zone.width, zone.height);
            ctx.clip();
            
            const startX = zone.x + (scrollOffsets[zoneIndex] % totalWidth);
            let currentX = startX;
            
            while (currentX < zone.x + zone.width + textWidth) {
                ctx.fillText(zone.text, currentX, y);
                currentX += totalWidth;
            }
            
            ctx.restore();
            
            ctx.shadowBlur = 0;
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            zones.forEach((zone, index) => {
                drawZone(zone, index);
            });
            
            if (isAnimating) {
                zones.forEach((zone, index) => {
                    scrollOffsets[index] -= zone.speed;
                    
                    ctx.font = `bold 48px 'HelveticaBoldExtended', 'HelveticaNeue-Bold', 'HelveticaNeue', Arial, sans-serif`;
                    const textWidth = ctx.measureText(zone.text).width + 50;
                    
                    if (scrollOffsets[index] <= -textWidth) {
                        scrollOffsets[index] = 0;
                    }
                });
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Listen for parameter updates (for live updates)
        window.addEventListener('message', (event) => {
            if (event.data.type === 'updateZones') {
                const newParams = event.data.zones;
                zones.forEach((zone, index) => {
                    const zoneNum = index + 1;
                    if (newParams[`zone${zoneNum}text`] !== undefined) {
                        zone.text = newParams[`zone${zoneNum}text`];
                    }
                    if (newParams[`zone${zoneNum}color`] !== undefined) {
                        zone.textColor = newParams[`zone${zoneNum}color`];
                    }
                    if (newParams[`zone${zoneNum}speed`] !== undefined) {
                        zone.speed = parseFloat(newParams[`zone${zoneNum}speed`]);
                    }
                });
            }
        });
        
        animate();
    </script>
</body>
</html>